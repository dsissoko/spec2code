{"version":3,"names":["isElementFocused","element","document","activeElement","wcsFocusableElements","isWcsFocusableElement","includes","tagName","toLowerCase","isFocusable","parseInt","getAttribute","disabled","boundingRect","getBoundingClientRect","bottom","top","left","right","height","width","x","y","style","display","visibility","opacity","nodeName","href","rel","type"],"sources":["src/utils/accessibility.ts"],"sourcesContent":["export function isElementFocused(element: HTMLElement): boolean {\n    return element === document.activeElement;\n}\n\nexport const wcsFocusableElements = [\n    'wcs-select',\n    'wcs-select-option',\n    'wcs-dropdown',\n    'wcs-dropdown-item',\n    'wcs-nav-item',\n    'wcs-button',\n    'wcs-input',\n    'wcs-textarea',\n    'wcs-checkbox',\n    'wcs-radio',\n    'wcs-switch',\n    'wcs-tab',\n    'wcs-counter',\n];\n\n/**\n * Returns true if the provided element is part of the wcsFocusableElements list\n */\nexport function isWcsFocusableElement(element: any): boolean {\n    return wcsFocusableElements.includes(element.tagName.toLowerCase());\n}\n\nexport function isFocusable(element: any): boolean {\n    if (parseInt(element.getAttribute('tabindex')) < 0) {\n        return false;\n    }\n    if (element.disabled) {\n        return false;\n    }\n    const boundingRect = element.getBoundingClientRect();\n    if (\n        boundingRect.bottom === 0 &&\n        boundingRect.top === 0 &&\n        boundingRect.left === 0 &&\n        boundingRect.right === 0 &&\n        boundingRect.height === 0 &&\n        boundingRect.width === 0 &&\n        boundingRect.x === 0 &&\n        boundingRect.y === 0\n    ) {\n        return false;\n    }\n    if (\n        element.style.display === 'none' ||\n        element.style.visibility === 'hidden' ||\n        element.style.opacity === 0\n    ) {\n        return false;\n    }\n    if (element.getAttribute('role') === 'button') {\n        return true;\n    }\n\n    if (isWcsFocusableElement(element)) {\n        return true;\n    }\n\n    // To identify other native focus elements.\n    switch (element.nodeName) {\n        case 'A':\n            return !!element.href && element.rel !== 'ignore';\n        case 'INPUT':\n            return element.type !== 'hidden';\n        case 'BUTTON':\n        case 'SELECT':\n        case 'TEXTAREA':\n            return true;\n        default:\n            return false;\n    }\n}\n\n/**\n * Finds the next focusable element after the given startElement.\n * It checks the next siblings of the startElement and returns the first focusable element found.\n * If no focusable element is found, it returns null.\n * @param startElement The element from which to start searching for the next focusable element.\n */\nexport function findNextFocusableElement(startElement: HTMLElement): HTMLElement | null {\n    let nextElement = startElement.nextElementSibling;\n    while (nextElement) {\n        if (isFocusable(nextElement) && nextElement instanceof HTMLElement) {\n            return nextElement;\n        }\n        nextElement = nextElement.nextElementSibling;\n    }\n    return null;\n}\n"],"mappings":"SAAgBA,EAAiBC,GAC7B,OAAOA,IAAYC,SAASC,aAChC,CAEO,MAAMC,EAAuB,CAChC,aACA,oBACA,eACA,oBACA,eACA,aACA,YACA,eACA,eACA,YACA,aACA,UACA,e,SAMYC,EAAsBJ,GAClC,OAAOG,EAAqBE,SAASL,EAAQM,QAAQC,cACzD,C,SAEgBC,EAAYR,GACxB,GAAIS,SAAST,EAAQU,aAAa,aAAe,EAAG,CAChD,OAAO,K,CAEX,GAAIV,EAAQW,SAAU,CAClB,OAAO,K,CAEX,MAAMC,EAAeZ,EAAQa,wBAC7B,GACID,EAAaE,SAAW,GACxBF,EAAaG,MAAQ,GACrBH,EAAaI,OAAS,GACtBJ,EAAaK,QAAU,GACvBL,EAAaM,SAAW,GACxBN,EAAaO,QAAU,GACvBP,EAAaQ,IAAM,GACnBR,EAAaS,IAAM,EACrB,CACE,OAAO,K,CAEX,GACIrB,EAAQsB,MAAMC,UAAY,QAC1BvB,EAAQsB,MAAME,aAAe,UAC7BxB,EAAQsB,MAAMG,UAAY,EAC5B,CACE,OAAO,K,CAEX,GAAIzB,EAAQU,aAAa,UAAY,SAAU,CAC3C,OAAO,I,CAGX,GAAIN,EAAsBJ,GAAU,CAChC,OAAO,I,CAIX,OAAQA,EAAQ0B,UACZ,IAAK,IACD,QAAS1B,EAAQ2B,MAAQ3B,EAAQ4B,MAAQ,SAC7C,IAAK,QACD,OAAO5B,EAAQ6B,OAAS,SAC5B,IAAK,SACL,IAAK,SACL,IAAK,WACD,OAAO,KACX,QACI,OAAO,MAEnB,Q"}